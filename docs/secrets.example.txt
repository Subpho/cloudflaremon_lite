# API Keys Configuration Example
# 
# IMPORTANT: Never commit actual secrets to your repository!
# This file shows the format only.
#
# Set API_KEYS secret using one of these methods:
# 1. Wrangler CLI: npx wrangler secret put API_KEYS
# 2. GitHub Secrets: Add in repo Settings → Secrets and variables → Actions
# 3. Cloudflare Dashboard: Workers → Your Worker → Settings → Variables
#
# See docs/SECURITY.md for detailed instructions

# API_KEYS Configuration - Now with Group & Wildcard Support!
# Format: {"key": "value", ...}
# Generate keys with: openssl rand -base64 32

# ============================================================================
# OPTION 1: Per-Service Keys (Most Secure)
# ============================================================================
# Each service has its own unique key - best for security
{
  "service-1": "unique-key-for-service-1",
  "service-2": "unique-key-for-service-2",
  "my-api": "unique-key-for-api"
}

# ============================================================================
# OPTION 2: Group-Level Keys (Recommended for Many Services)
# ============================================================================
# All services in a group share the same key
# Perfect for Kubernetes with many nodes!
{
  "core-services": "shared-key-for-core-group",
  "infrastructure": "shared-key-for-infra-group",
  "kubernetes": "shared-key-for-k8s-cluster"
}
# With this setup:
# - All services in "core-services" group use "shared-key-for-core-group"
# - All services in "infrastructure" group use "shared-key-for-infra-group"
# - All services in "kubernetes" group use "shared-key-for-k8s-cluster"

# ============================================================================
# OPTION 3: Wildcard Key (Simplest)
# ============================================================================
# ALL services use the same key
{
  "*": "one-key-for-everything"
}

# ============================================================================
# OPTION 4: Hybrid (Most Flexible)
# ============================================================================
# Mix all approaches - Priority order:
# 1. Specific service key (highest)
# 2. Group key (medium)
# 3. Wildcard "*" (lowest)
{
  "payment-api": "super-secure-key",         # Specific service (priority 1)
  "core-services": "shared-core-key",        # Group key (priority 2)
  "kubernetes": "k8s-key",                   # Group key (priority 2)
  "*": "default-key-for-others"              # Fallback (priority 3)
}

# ============================================================================
# KEY LOOKUP LOGIC
# ============================================================================
# When a heartbeat arrives for "service-1":
# 1. Check for exact match: apiKeys["service-1"]
# 2. If not found, check group: apiKeys["core-services"] (if service-1 is in that group)
# 3. If not found, check wildcard: apiKeys["*"]
# 4. First match wins!

# ============================================================================
# EXAMPLES BY USE CASE
# ============================================================================

# Example 1: Simple Setup (Use Wildcard)
{"*": "my-shared-secret"}

# Example 2: Kubernetes (50 nodes - Use Group Key)
{"kubernetes": "k8s-cluster-key"}
# Don't want to list all 50 nodes!

# Example 3: Production (Mix of Security Levels)
{
  "payment-api": "critical-secret-key",
  "admin-api": "admin-secret-key",
  "monitoring-group": "monitoring-key",
  "*": "default-key"
}

# One-line version for command line:
# {"kubernetes":"k8s-key","*":"default-key"}

